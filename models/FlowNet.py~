#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Developed by Shangchen Zhou <zhoushangchen@sensetime.com>

# from models.submodules import *
#
# class DispNet_Bi(nn.Module):
#     def __init__(self):
#         super(DispNet_Bi, self).__init__()
#
#         self.conv0   = conv(6,   64, kernel_size=3, stride=1)
#
#         self.conv1   = conv(64,   64, kernel_size=3, stride=2)
#         self.conv1_1 = conv(64,   64, kernel_size=3, stride=1)
#
#         self.conv2   = conv(64, 128, kernel_size=3, stride=2)
#         self.conv2_1 = conv(128, 128, kernel_size=3, stride=1)
#
#         self.conv3   = conv(128, 256, kernel_size=3, stride=2)
#         self.conv3_1 = conv(256, 256, kernel_size=3, stride=1)
#
#         self.conv4   = conv(256, 512, kernel_size=3, stride=2)
#         self.conv4_1 = conv(512, 512, kernel_size=3, stride=1)
#
#         self.dilconv5_1a = conv(512, 256, kernel_size=3, stride=1, dilation=2)
#         self.dilconv5_2a = conv(256, 256, kernel_size=3, stride=1, dilation=2)
#         self.conv5_a = conv(256, 256, kernel_size=3, stride=1)
#
#         self.dilconv5_1b = conv(512, 256, kernel_size=3, stride=1, dilation=2)
#         self.dilconv5_2b = conv(256, 256, kernel_size=3, stride=1, dilation=4)
#         self.conv5_b = conv(256, 256, kernel_size=3, stride=1)
#
#         self.dilconv5_1c = conv(512, 256, kernel_size=3, stride=1, dilation=3)
#         self.dilconv5_2c = conv(256, 256, kernel_size=3, stride=1, dilation=3)
#         self.conv5_c = conv(256, 256, kernel_size=3, stride=1)
#
#         self.dilconv5_1d = conv(512, 256, kernel_size=3, stride=1, dilation=4)
#         self.dilconv5_2d = conv(256, 256, kernel_size=3, stride=1, dilation=4)
#         self.conv5_d = conv(256, 256, kernel_size=3, stride=1)
#         self.inter_conv5 = conv(1024, 1024, kernel_size=3, stride=1)
#
#         self.conv5_disp = conv(1024, 512)
#
#         self.upconv4disp = conv(512,  256, kernel_size=3, stride=1)
#         self.upconv3disp = upconv(256,128)
#         self.upconv2disp = upconv(128,64)
#         self.upconv1disp = upconv(64,32)
#
#         self.inter_conv4disp = conv(770,  256, kernel_size=3, stride=1)
#         self.inter_conv3disp = conv(386,  128, kernel_size=3, stride=1)
#         self.inter_conv2disp = conv(194,   64, kernel_size=3, stride=1)
#         self.inter_conv1disp = conv(34,   32, kernel_size=3, stride=1)
#
#         self.predict_disp_bi_5 = predict_disp_bi(512)
#         self.predict_disp_bi_4 = predict_disp_bi(256)
#         self.predict_disp_bi_3 = predict_disp_bi(128)
#         self.predict_disp_bi_2 = predict_disp_bi(64)
#         self.predict_disp_bi_1 = predict_disp_bi(32)
#
#         self.upsampled_disp_bi_4_to_3 = nn.ConvTranspose2d(2, 2, 4, 2, 1, bias=False)
#         self.upsampled_disp_bi_3_to_2 = nn.ConvTranspose2d(2, 2, 4, 2, 1, bias=False)
#         self.upsampled_disp_bi_2_to_1 = nn.ConvTranspose2d(2, 2, 4, 2, 1, bias=False)
#
#     def forward(self, x):
#         out_conv0 = self.conv0(x)
#         out_conv1 = self.conv1_1(self.conv1(out_conv0))
#         out_conv2 = self.conv2_1(self.conv2(out_conv1))
#         out_conv3 = self.conv3_1(self.conv3(out_conv2))
#         out_conv4 = self.conv4_1(self.conv4(out_conv3))
#         out_conv5a = self.conv5_a(self.dilconv5_2a(self.dilconv5_1a(out_conv4)))
#         out_conv5b = self.conv5_b(self.dilconv5_2b(self.dilconv5_1b(out_conv4)))
#         out_conv5c = self.conv5_c(self.dilconv5_2c(self.dilconv5_1c(out_conv4)))
#         out_conv5d = self.conv5_d(self.dilconv5_2d(self.dilconv5_1d(out_conv4)))
#         concat5 = torch.cat((out_conv5a, out_conv5b, out_conv5c, out_conv5d),1)
#         out_conv5 = self.inter_conv5(concat5)
#
#         out_conv5_disp = self.conv5_disp(out_conv5)
#
#         disp_bi_5 = self.predict_disp_bi_5(out_conv5_disp)
#         out_upconv4disp = self.upconv4disp(out_conv5_disp)
#
#         concat4disp = cat_with_crop(out_conv4, [out_conv4, out_upconv4disp, disp_bi_5])
#         out_inter_conv4disp = self.inter_conv4disp(concat4disp)
#         disp_bi_4 = self.predict_disp_bi_4(out_inter_conv4disp)
#         disp_bi_4_up = self.upsampled_disp_bi_4_to_3(disp_bi_4)
#         out_upconv3disp = self.upconv3disp(out_inter_conv4disp)
#
#
#         concat3disp = cat_with_crop(out_conv3, [out_conv3, out_upconv3disp, disp_bi_4_up])
#         out_inter_conv3disp = self.inter_conv3disp(concat3disp)
#         disp_bi_3 = self.predict_disp_bi_3(out_inter_conv3disp)
#         disp_bi_3_up = self.upsampled_disp_bi_3_to_2(disp_bi_3)
#         out_upconv2disp = self.upconv2disp(out_inter_conv3disp)
#
#         concat2disp = cat_with_crop(out_conv2, [out_conv2, out_upconv2disp, disp_bi_3_up])
#         out_inter_conv2disp = self.inter_conv2disp(concat2disp)
#         disp_bi_2 = self.predict_disp_bi_2(out_inter_conv2disp)
#         disp_bi_2_up = self.upsampled_disp_bi_2_to_1(disp_bi_2)
#         out_upconv1disp = self.upconv1disp(out_inter_conv2disp)
#
#         concat1disp = cat_with_crop(out_conv1, [out_upconv1disp, disp_bi_2_up])
#         out_inter_conv1disp = self.inter_conv1disp(concat1disp)
#         disp_bi_1 = self.predict_disp_bi_1(out_inter_conv1disp)
#
#         if self.training:
#             return disp_bi_1, disp_bi_2, disp_bi_3, disp_bi_4, disp_bi_5
#         else:
#             return disp_bi_1

#
# from models.submodules import *
# # 2018-10-14T20:20:54.499591_DispNet_Bi
# class DispNet_Bi(nn.Module):
#     def __init__(self):
#         super(DispNet_Bi, self).__init__()
#         # encoder
#         ks = 3
#         self.conv0 = conv(6,    48, kernel_size=ks, stride=1)
#
#         self.conv1_1 = conv(48,   48, kernel_size=ks, stride=2)
#         self.conv1_2 = conv(48,   48, kernel_size=ks, stride=1)
#
#         self.conv2_1 = conv(48,   96, kernel_size=ks, stride=2)
#         self.conv2_2 = conv(96,   96, kernel_size=ks, stride=1)
#
#         self.conv3_1 = conv(96,  128, kernel_size=ks, stride=2)
#         self.conv3_2 = conv(128,  128, kernel_size=ks, stride=1)
#
#         self.conv4_1 = resnet_block(128, kernel_size=ks)
#         self.conv4_2 = resnet_block(128, kernel_size=ks)
#
#         self.convd_1 = resnet_block(128, kernel_size=ks, dilation = [2,1])
#         self.convd_2 = ms_dilate_block(128, kernel_size=ks, dilation = [1, 2, 3, 4])
#
#         # decoder
#         self.upconvd_i = conv(128,  128, kernel_size=ks, stride=1)
#         self.dispd = predict_disp_bi(128)
#
#         self.upconv3 = conv(128,  128, kernel_size=ks, stride=1)
#         self.upconv3_i = conv(258, 128, kernel_size=ks, stride=1)
#         self.upconv3_f = conv(128, 128, kernel_size=ks, stride=1)
#         self.disp3 = predict_disp_bi(128)
#
#         self.updisp2 = up_disp_bi()
#         self.upconv2 = upconv(128, 96)
#         self.upconv2_i = conv(194, 96, kernel_size=ks, stride=1)
#         self.upconv2_f = conv(96, 96, kernel_size=ks, stride=1)
#         self.disp2 = predict_disp_bi(96)
#
#         self.updisp1 = up_disp_bi()
#         self.upconv1 = upconv(96, 48)
#         self.upconv1_i = conv(50, 48, kernel_size=ks, stride=1)
#         self.upconv1_f = conv(48, 48, kernel_size=ks, stride=1)
#         self.disp1 = predict_disp_bi(48)
#
#     def forward(self, x):
#         # encoder
#         conv0 = self.conv0(x)
#         conv1 = self.conv1_2(self.conv1_1(conv0))
#         conv2 = self.conv2_2(self.conv2_1(conv1))
#         conv3 = self.conv3_2(self.conv3_1(conv2))
#         conv4 = self.conv4_2(self.conv4_1(conv3))
#         convd = self.convd_2(self.convd_1(conv4))
#
#         # decoder
#         upconvd_i = self.upconvd_i(convd)
#         disp4 = self.dispd(upconvd_i)
#
#         upconv3 = self.upconv3(upconvd_i)
#         cat3 = cat_with_crop(conv3, [conv3, upconv3, disp4])
#         upconv3_i = self.upconv3_f(self.upconv3_i(cat3))
#         disp3 = self.disp3(upconv3_i)
#
#         updisp2 = self.updisp2(disp3)
#         upconv2 = self.upconv2(upconv3_i)
#         cat2 = cat_with_crop(conv2, [conv2, upconv2, updisp2])
#         upconv2_i = self.upconv2_f(self.upconv2_i(cat2))
#         disp2 = self.disp2(upconv2_i)
#
#         updisp1 = self.updisp1(disp2)
#         upconv1 = self.upconv1(upconv2_i)
#         cat1 = cat_with_crop(conv1, [upconv1, updisp1])
#         upconv1_i = self.upconv1_f(self.upconv1_i(cat1))
#         disp1 = self.disp1(upconv1_i)
#
#         if self.training:
#             return disp1, disp2, disp3, disp4
#         else:
#             return disp1


# from models.submodules import *
# # remove disps concat 2018-10-15T01:46:13.500025_DispNet_Bi
# class DispNet_Bi(nn.Module):
#     def __init__(self):
#         super(DispNet_Bi, self).__init__()
#         # encoder
#         ks = 3
#         self.conv0 = conv(6,    48, kernel_size=ks, stride=1)
#
#         self.conv1_1 = conv(48,   48, kernel_size=ks, stride=2)
#         self.conv1_2 = conv(48,   48, kernel_size=ks, stride=1)
#
#         self.conv2_1 = conv(48,   96, kernel_size=ks, stride=2)
#         self.conv2_2 = conv(96,   96, kernel_size=ks, stride=1)
#
#         self.conv3_1 = conv(96,  128, kernel_size=ks, stride=2)
#         self.conv3_2 = conv(128,  128, kernel_size=ks, stride=1)
#
#         self.conv4_1 = resnet_block(128, kernel_size=ks)
#         self.conv4_2 = resnet_block(128, kernel_size=ks)
#
#         self.convd_1 = resnet_block(128, kernel_size=ks, dilation = [2,1])
#         self.convd_2 = ms_dilate_block(128, kernel_size=ks, dilation = [1, 2, 3, 4])
#
#         # decoder
#         self.upconvd_i = conv(128,  128, kernel_size=ks, stride=1)
#         self.dispd = predict_disp_bi(128)
#
#         self.upconv3 = conv(128,  128, kernel_size=ks, stride=1)
#         self.upconv3_i = conv(256, 128, kernel_size=ks, stride=1)
#         self.upconv3_r = conv(128, 128, kernel_size=ks, stride=1)
#         self.disp3 = predict_disp_bi(128)
#
#         self.upconv2 = upconv(128, 96)
#         self.upconv2_i = conv(192, 96, kernel_size=ks, stride=1)
#         self.upconv2_r = conv(96, 96, kernel_size=ks, stride=1)
#         self.disp2 = predict_disp_bi(96)
#
#         self.upconv1 = upconv(96, 48)
#         self.upconv1_i = conv(48, 48, kernel_size=ks, stride=1)
#         self.upconv1_r = conv(48, 48, kernel_size=ks, stride=1)
#         self.disp1 = predict_disp_bi(48)
#
#     def forward(self, x):
#         # encoder
#         conv0 = self.conv0(x)
#         conv1 = self.conv1_2(self.conv1_1(conv0))
#         conv2 = self.conv2_2(self.conv2_1(conv1))
#         conv3 = self.conv3_2(self.conv3_1(conv2))
#         conv4 = self.conv4_2(self.conv4_1(conv3))
#         convd = self.convd_2(self.convd_1(conv4))
#
#         # decoder
#         upconvd_i = self.upconvd_i(convd)
#         disp4 = self.dispd(upconvd_i)
#
#         upconv3 = self.upconv3(upconvd_i)
#         cat3 = cat_with_crop(conv3, [conv3, upconv3])
#         upconv3_i = self.upconv3_r(self.upconv3_i(cat3))
#         disp3 = self.disp3(upconv3_i)
#
#         upconv2 = self.upconv2(upconv3_i)
#         cat2 = cat_with_crop(conv2, [conv2, upconv2])
#         upconv2_i = self.upconv2_r(self.upconv2_i(cat2))
#         disp2 = self.disp2(upconv2_i)
#
#         upconv1 = self.upconv1(upconv2_i)
#         upconv1_i = self.upconv1_r(self.upconv1_i(upconv1))
#         disp1 = self.disp1(upconv1_i)
#
#         if self.training:
#             return disp1, disp2, disp3, disp4
#         else:
#             return disp1

# from models.submodules import *
# import torch.nn.functional as F
# class DispNet_Bi(nn.Module):
#     def __init__(self):
#         super(DispNet_Bi, self).__init__()
#         # encoder
#         ks = 3
#         self.conv0 = conv(6,    48, kernel_size=ks, stride=1)
#
#         self.conv1_1 = conv(48,   48, kernel_size=ks, stride=2)
#         self.conv1_2 = conv(48,   48, kernel_size=ks, stride=1)
#
#         self.conv2_1 = conv(48,   96, kernel_size=ks, stride=2)
#         self.conv2_2 = conv(96,   96, kernel_size=ks, stride=1)
#
#         self.conv3_1 = conv(96,  128, kernel_size=ks, stride=2)
#         self.conv3_2 = conv(128,  128, kernel_size=ks, stride=1)
#
#         self.conv4_1 = resnet_block(128, kernel_size=ks)
#         self.conv4_2 = resnet_block(128, kernel_size=ks)
#
#         self.convd_1 = resnet_block(128, kernel_size=ks, dilation = [2,1])
#         self.convd_2 = ms_dilate_block(128, kernel_size=ks, dilation = [1, 2, 3, 4])
#
#         # decoder
#         self.upconvd_i = conv(128,  128, kernel_size=ks, stride=1)
#         self.dispd = predict_disp_bi(128)
#
#         self.upconv3 = conv(128,  128, kernel_size=ks, stride=1)
#         self.upconv3_i = conv(258, 128, kernel_size=ks, stride=1)
#         self.upconv3_f = conv(128, 128, kernel_size=ks, stride=1)
#         self.disp3 = predict_disp_bi(128)
#
#         self.updisp3 = up_disp_bi()
#         self.upconv2 = upconv(128, 96)
#         self.upconv2_i = conv(194, 96, kernel_size=ks, stride=1)
#         self.upconv2_f = conv(96, 96, kernel_size=ks, stride=1)
#         self.disp2 = predict_disp_bi(96)
#
#         self.updisp2 = up_disp_bi()
#         self.upconv1 = upconv(96, 48)
#         self.upconv1_i = conv(50, 48, kernel_size=ks, stride=1)
#         self.upconv1_f = conv(48, 48, kernel_size=ks, stride=1)
#         self.disp1 = predict_disp_bi(48)
#
#
#     def forward(self, x):
#         # encoder
#         conv0 = self.conv0(x)
#         conv1 = self.conv1_2(self.conv1_1(conv0))
#         conv2 = self.conv2_2(self.conv2_1(conv1))
#         conv3 = self.conv3_2(self.conv3_1(conv2))
#         conv4 = self.conv4_2(self.conv4_1(conv3))
#         convd = self.convd_2(self.convd_1(conv4))
#
#         # decoder
#         upconvd_i = self.upconvd_i(convd)
#         disp4 = self.dispd(upconvd_i)
#
#         upconv3 = self.upconv3(upconvd_i)
#         cat3 = torch.cat([conv3, upconv3, disp4],1)
#         upconv3_i = self.upconv3_f(self.upconv3_i(cat3))
#         disp3 = self.disp3(upconv3_i) + disp4
#
#         updisp3 = self.updisp3(disp3)
#         upconv2 = self.upconv2(upconv3_i)
#         cat2 = torch.cat([conv2, upconv2, updisp3],1)
#         upconv2_i = self.upconv2_f(self.upconv2_i(cat2))
#         disp2 = self.disp2(upconv2_i) + updisp3
#
#         updisp2 = self.updisp2(disp2)
#         upconv1 = self.upconv1(upconv2_i)
#         cat1 = torch.cat([upconv1, updisp2],1)
#         upconv1_i = self.upconv1_f(self.upconv1_i(cat1))
#         disp1 = self.disp1(upconv1_i) + updisp2
#
#         if self.training:
#             return disp1, disp2, disp3, disp4
#         else:
#             return disp1

from models.submodules import *
import torch.nn.functional as F


class DispNet_Bi(nn.Module):
    def __init__(self):
        super(DispNet_Bi, self).__init__()
        # encoder
        ks = 3
        self.conv0 = conv(6, 48, kernel_size=ks, stride=1)

        self.conv1_1 = conv(48, 48, kernel_size=ks, stride=2)
        self.conv1_2 = conv(48, 48, kernel_size=ks, stride=1)

        self.conv2_1 = conv(48, 96, kernel_size=ks, stride=2)
        self.conv2_2 = conv(96, 96, kernel_size=ks, stride=1)

        self.conv3_1 = conv(96, 128, kernel_size=ks, stride=2)
        self.conv3_2 = conv(128, 128, kernel_size=ks, stride=1)

        self.conv4_1 = resnet_block(128, kernel_size=ks)
        self.conv4_2 = resnet_block(128, kernel_size=ks)

        self.convd_1 = resnet_block(128, kernel_size=ks, dilation=[2, 1])
        self.convd_2 = ms_dilate_block(128, kernel_size=ks, dilation=[1, 2, 3, 4])

        # decoder
        self.upconvd_i = conv(128, 128, kernel_size=ks, stride=1)
        self.dispd = predict_disp_bi(128)

        self.upconv3 = conv(128, 128, kernel_size=ks, stride=1)
        self.upconv3_i = conv(258, 128, kernel_size=ks, stride=1)
        self.upconv3_f = conv(128, 128, kernel_size=ks, stride=1)
        self.disp3 = predict_disp_bi(128)

        self.updisp3 = up_disp_bi()
        self.upconv2 = upconv(128, 96)
        self.upconv2_i = conv(194, 96, kernel_size=ks, stride=1)
        self.upconv2_f = conv(96, 96, kernel_size=ks, stride=1)
        self.disp2 = predict_disp_bi(96)

        self.updisp2 = up_disp_bi()
        self.upconv1 = upconv(96, 48)
        self.upconv1_i = conv(50, 48, kernel_size=ks, stride=1)
        self.upconv1_f = conv(48, 48, kernel_size=ks, stride=1)
        self.disp1 = predict_disp_bi(48)

        self.updisp1 = up_disp_bi()
        self.upconv0 = upconv(48, 32)
        self.upconv0_i = conv(34, 32, kernel_size=ks, stride=1)
        self.upconv0_f = conv(32, 32, kernel_size=ks, stride=1)
        self.disp0 = predict_disp_bi(32)

    def forward(self, x):
        # encoder
        conv0 = self.conv0(x)
        conv1 = self.conv1_2(self.conv1_1(conv0))
        conv2 = self.conv2_2(self.conv2_1(conv1))
        conv3 = self.conv3_2(self.conv3_1(conv2))
        conv4 = self.conv4_2(self.conv4_1(conv3))
        convd = self.convd_2(self.convd_1(conv4))

        # decoder
        upconvd_i = self.upconvd_i(convd)
        disp4 = self.dispd(upconvd_i)

        upconv3 = self.upconv3(upconvd_i)
        cat3 = torch.cat([conv3, upconv3, disp4], 1)
        upconv3_i = self.upconv3_f(self.upconv3_i(cat3))
        disp3 = self.disp3(upconv3_i) + disp4

        updisp3 = self.updisp3(disp3)
        upconv2 = self.upconv2(upconv3_i)
        cat2 = torch.cat([conv2, upconv2, updisp3], 1)
        upconv2_i = self.upconv2_f(self.upconv2_i(cat2))
        disp2 = self.disp2(upconv2_i) + updisp3

        updisp2 = self.updisp2(disp2)
        upconv1 = self.upconv1(upconv2_i)
        cat1 = torch.cat([upconv1, updisp2], 1)
        upconv1_i = self.upconv1_f(self.upconv1_i(cat1))
        disp1 = self.disp1(upconv1_i) + updisp2

        updisp1 = self.updisp1(disp1)
        upconv0 = self.upconv0(upconv1_i)
        cat0 = torch.cat([upconv0, updisp1], 1)
        upconv0_i = self.upconv0_f(self.upconv0_i(cat0))
        disp0 = self.disp0(upconv0_i) + updisp1

        # if self.training:
        #     return disp0, disp1, disp2, disp3, disp4
        # else:
        #     return disp0

        if self.training:
            return disp0, disp1, disp2, disp3, disp4, upconv0_i
        else:
            return disp0, upconv0_i